МІНІСТЕРСТВО ОСВІТИ ТА НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра Програмної інженерії



ЗВІТ
З дисципліни «Архітектура програмного забезпечення»
З практичної роботи №1
На тему: «Патерни проєктування»



Виконав: 									Перевірив:
Ст. гр. ПЗПІ-22-6 							      	Ст. вик. каф. ПІ
Шараєв Б. О. 								Сокорчук І. П.










Харків 2025
1 ІСТОРІЯ ЗМІН
Зміни звіту наведені у таблиці 1.1
Таблиця 1.1 – Історія змін
№	Дата	Версія звіту	Опис змін
1	14.04.2025	0.1	Створено розділ «Історія змін»
2	15.04.2025	0.1	Створено розділ «Завдання»
3	15.04.2025	0.1	Створено розділ “Опис виконаної роботи”
4	15.04.2025	0.1	Створено розділ “Висновки”
5	16.04.2025	0.1	Додані слайди презентації у Додаток Б
6	18.04.2025	0.1	Додані приклади програмного коду у Додаток А
7	18.04.2025	0.1	Додані посилання і хронологічний опис доповіді у Додаток А



















2 ЗАВДАННЯ
1.	Підготувати доповідь на тему: «Шаблон (патерн) проєктування ПЗ».
2.	Створити та оформити слайди презентації доповіді.
3.	Створити та опублікувати на YouTube відеозапис доповіді.
4.	Оформити та завантажити на dl.nure.ua звіт до виконаної роботи.
5.	При потребі створити та налаштувати у GitHub обліковий запис для облікового запису студента в домені @nure.ua.
6.	Створити для виконання завдань з дисципліни GitHub репозиторій iз вказаним на https://dl.nure.ua іменем та з головною гілкою main.
7.	Створити у корені створеного репозиторію файл README.md з вказаним далі змістом та вказані далі директорії для окремих завдань.
8.	Експортувати звіт у файл у простому текстововому форматі та завантажити цей файл у директорію Pract1 у репозиторії GitHub.
9.	Завантажити у вказану далі піддиректорію увесь програмний код, який розглядається у доповіді ПЗ1.














3 ОПИС ВИКОНАНОЇ РОБОТИ
Патерн «Декоратор» та яку проблему вирішує. 
Визначення патерну:
Патерн Декоратор (Decorator) — це структурний шаблон проєктування, який дозволяє динамічно додавати нову поведінку або функціональність об’єктам, не змінюючи їхньої початкової реалізації. Він створює обгортку навколо об’єкта, яка реалізує той самий інтерфейс і може змінювати його поведінку.
Основна ідея:
Основна ідея патерну полягає в додаванні нової функціональності до об’єкта без зміни його початкового коду. Це досягається через обгортання об’єкта іншими об’єктами-декораторами, які розширюють або змінюють поведінку, викликаючи методи базового об’єкта до або після своєї логіки.
Яку проблему вирішує:
У програмуванні часто виникає ситуація, коли потрібно динамічно додавати нову поведінку до об’єктів. Один із поширених підходів — створення підкласів через наслідування. Проте цей підхід має серйозні недоліки. Зі збільшенням кількості можливих варіацій поведінки кількість класів стрімко росте. 
Патерн Декоратор вирішує цю проблему, дозволяючи додавати функціональність до об’єктів під час виконання програми — без створення великої кількості підкласів і без зміни коду самого об’єкта. 
Структура патерну:
Розглянему структуру патерну Декоратор.
Компонент — це базова одиниця, яка визначає загальний інтерфейс для усіх конкретних реалізацій та декораторів. Він може бути абстрактним класом або інтерфейсом, який гарантує, що всі об'єкти, які надають поведінку через цей інтерфейс, матимуть спільний метод для виконання основних операцій.
ConcreteComponent —  є класом, який реалізує цей інтерфейс або абстрактний клас, і виконує основну логіку операцій. Це фактично реальний об'єкт, який здійснює базові функції, такі як виведення тексту, розрахунок вартості або інші функції без додаткових змін. Це ядро, яке містить основну бізнес-логіку, до якого додаються нові можливості через декоратори.
Декоратор — це абстрактний клас, який також реалізує інтерфейс компонента. Важливо, що декоратор містить поле, яке є посиланням на об'єкт компонента. Це поле використовується для зберігання посилання на той компонент, який необхідно декорувати. Метод someOperation() в декораторі викликає відповідний метод у об'єкта, який зберігається в цьому полі, таким чином передаючи виконання до декорованого компонента.
ConcreteDecorator1 і ConcreteDecorator2 — це конкретні реалізації декораторів. Кожен з них додає специфічну поведінку до результату виклику методу someOperation() у базовому компоненті або іншому декораторі. Ці класи дозволяють додавати різні функціональні можливості без зміни існуючого коду компонентів, реалізуючи додаткову поведінку через перевизначення методів.

Переваги патерну Декоратор:
Патерн дозволяє динамічно розширювати функціональність об'єктів під час виконання програми, не змінюючи їхнього початкового коду. Це забезпечує високу гнучкість, адже різні декоратори можна комбінувати в будь-якому порядку, створюючи потрібні варіації поведінки без необхідності створювати багато підкласів. Таким чином досягається принцип композиції замість наслідування. Крім того, декоратори сприяють кращому розділенню відповідальностей: кожен з них реалізує окремий аспект функціоналу, що робить код чистішим, структурованішим і легшим у підтримці.

Недоліки патерну Декоратор:
Недоліки патерну Декоратор включають кілька важливих аспектів. По-перше, застосування великої кількості декораторів може ускладнити структуру коду, особливо коли вони глибоко вкладені один в одного — це робить систему важкою для розуміння та підтримки. По-друге, виникають труднощі з відстеженням виконання, оскільки методи викликаються каскадно, і не завжди зрозуміло, яка саме поведінка була додана і в якому порядку.























4 ВИСНОВКИ
Патерн проєктування «Декоратор» дозволяє додавати нову функціональність до об'єктів без змін у їхньому коді, що відповідає принципу відкритості/закритості. Він забезпечує гнучкість, дозволяючи комбінувати декоратори для створення складних функціональностей. Це полегшує підтримку і тестування коду, оскільки кожен декоратор відповідає лише за певну частину функціональності. Однак, надмірне використання декораторів може призвести до складності у розумінні системи. Отже, патерн є ефективним для розширення можливостей об'єктів без порушення їхньої основної логіки.




















Додаток А
Посилання на відео та хронологічний опис

Відеозапис доповіді на YouTube: https://youtu.be/w-B-drEqrB8 
Хронологічний опис доповіді:
0:01 - Вступна частина.
0:10 - Визначення патерну декоратор.
0:27 - Основна ідея патерну.
01:16 - Яку проблему вирішує патерн?
02:20 - Структура патерну.
03:48 - Приклад реалізації патерну.
04:43 - Переваги патерну.
05:16 - Недоліки патерну.
05:53 - Висновки.
06:24 - Список використаних джерел.
06:26 - Дякую за увагу.














Додаток Б
Слайди презентації
 
Рисунок Б.1 – Титульний слайд.
 
Рисунок Б.2 – Визначення патерну «Декоратор».
 
Рисунок Б.3 – Основна ідея патерну «Декоратор».

 
Рисунок Б.4 – Проблема, що вирішує патерн «Декоратор».

 
Рисунок Б.5 – Структура патерну «Декоратор».
 
Рисунок Б.6 – Приклад реалізації патерна «Декоратор».

 
Рисунок Б.7 – Приклад реалізації патерна «Декоратор».

 
Рисунок Б.8 – Переваги патерну «Декоратор».

 
Рисунок Б.9 – Недоліки патерну «Декоратор».

 
Рисунок Б.10 – Висновки доповіді.

 
Рисунок Б.11 – Список використаних джерел.


 
Рисунок Б.12 – Слайд презентації «Дякую за увагу».



Додаток В
Програмний код
1 import java.time.LocalTime;
2 import java.time.format.DateTimeFormatter;
3 
4 interface IRadiation {
5     double getRadiationLevel();
6 }
7 
8 class Radiation implements IRadiation {
9     private final double level;
10 
11     public Radiation(double level) {
12         this.level = level;
13     }
14 
15     @Override
16     public double getRadiationLevel() {
17         return level;
18     }
19 }
20 
21 abstract class RadiationDecorator implements IRadiation {
22     protected IRadiation baseData;
23 
24     public RadiationDecorator(IRadiation baseData) {
25         this.baseData = baseData;
26     }
27 
28     @Override
29     public double getRadiationLevel() {
30         return baseData.getRadiationLevel();
31     }
32 }
33 
34 class LogRadiationDecorator extends RadiationDecorator {
35 
36     public LogRadiationDecorator(IRadiation baseData) {
37         super(baseData);
38     }
39 
40     @Override
41     public double getRadiationLevel() {
42         double level = baseData.getRadiationLevel();
43         LocalTime now = LocalTime.now();
44         DateTimeFormatter formatter = DateTimeFormatter.ofPattern("HH:mm");
45         String formattedTime = now.format(formatter);
46         System.out.println("Radiation level at " + formattedTime + ": " + level);
47         return level;
48     }
49 }
50 
51 public class Main {
52     public static void main(String[] args) {
53         IRadiation data = new Radiation(3.45);
54 
55         IRadiation loggedData = new LogRadiationDecorator(data);
56 
57         System.out.println("Final radiation level: " + loggedData.getRadiationLevel());
58     }
59 }

